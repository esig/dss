:toc: left
:icons: font
= Digital Signature Service
:description: Documentation of the open source project DSS (Digital Signature Service). This project allows to produce/validate advanced electronic signatures (AdES).
:keywords: electronic signature, XAdES, CAdES, PAdES, ASiC, open source, validation
version : {dssVersion} - {docdate}

== Introduction

=== Purpose of the document

This document describes some examples of how to develop in Java using the DSS framework. The aim is to show to the developers, in a progressive manner, the different uses of the framework. It will familiarise them with the code step by step.

=== Scope of the document

This document provides examples of code which allow easy handling of digital signatures. The examples are consistent with the Release {dssVersion} of DSS framework which can be downloaded via https://ec.europa.eu/cefdigital/wiki/display/CEFDIGITAL/DSS+-+releases

Three main features can be distinguished within the framework :

 * The digital signature;
 * The extension of a digital signature and;
 * The validation of a digital signature.
 
On a more detailed manner the following concepts and features are addressed in this document:
 
 * Formats of the signed documents: XML, PDF, DOC, TXT, ZIP...;
 * Packaging structures: enveloping, enveloped, detached and internally-detached;
 * Forms of digital signatures: XAdES, CAdES, PAdES and ASiC-S/ASiC-E;
 * Profiles associated to each form of the digital signature;
 * Trust management;
 * Revocation data handling (OCSP and CRL sources);
 * Certificate chain building;
 * Signature validation and validation policy;
 * Validation of the signing certificate.

This is not an exhaustive list of all the possibilities offered by the framework and the proposed examples cover only the most useful features. However, to discover every detail of the operational principles of the framework, the JavaDoc is available within the source code.

Please note that the DSS framework is still under maintenance and new features will be released in the future.

=== Abbreviations and Acronyms

[cols=2]
|=======================
|Code			|Description
|AdES			|Advanced Electronic Signature
|API			|Application Programming Interface
|ASiC			|Associated Signature Containers
|BB				|Building Block (CEF)
|CA				|Certificate authority
|CAdES			|CMS Advanced Electronic Signatures
|CD				|Commission Decision
|CEF			|Connecting Europe Facility
|CMS			|Cryptographic Message Syntax
|CRL			|Certificate Revocation List
|CSP			|Core Service Platform (CEF)
|CSP			|Cryptographic Service Provider
|DER			|Distinguished Encoding Rules
|DSA			|Digital Signature Algorithm - an algorithm for public-key cryptography
|DSI			|Digital Service Infrastructure (CEF)
|DSS			|Digital Signature Service
|EC				|European Commission
|eID			|Electronic Identity Card
|ESI			|Electronic Signatures and Infrastructures
|ETSI			|European Telecommunications Standards Institute
|EUPL			|European Union Public License
|FSF			|Free Software Foundation
|GS				|Generic Service (CEF)
|GUI			|Graphical User Interface
|HSM			|Hardware Security Modules
|HTTP			|Hypertext Transfer Protocol
|I18N			|Internationalisation
|Java EE		|Java Enterprise Edition
|JavaDoc		|JavaDoc is developed by Sun Microsystems to create API documentation in HTML format from the comments in the source code. JavaDoc is an industrial standard for documenting Java classes.
|JAXB			|Java Architecture for XML Binding
|JCA			|Java Cryptographic Architecture
|JCE			|Java Cryptography Extension
|JDBC			|Java DataBase Connectivity
|LGPL			|Lesser General Public License
|LOTL			|List of Trusted List or List of the Lists
|LSP			|Large Scale Pilot
|MIT			|Massachusetts Institute of Technology
|MOCCA			|Austrian Modular Open Citizen Card Architecture; implemented in Java
|MS / EUMS		|Member State
|MS CAPI		|Microsoft Cryptographic Application Programming Interface
|OCF			|OEBPS Container Format
|OCSP			|Online Certificate Status Protocol
|ODF			|Open Document Format
|ODT			|Open Document Text
|OEBPS			|Open eBook Publication Structure
|OID			|Object Identifier
|OOXML			|Office Open XML
|OSI			|Open Source Initiative
|OSS			|Open Source Software
|PAdES			|PDF Advanced Electronic Signatures
|PC/SC			|Personal computer/Smart Card
|PDF			|Portable Document Format
|PDFBox			|Apache PDFBox - A Java PDF Library: http://pdfbox.apache.org/
|PKCS			|Public Key Cryptographic Standards
|PKCS#12		|It defines a file format commonly used to store X.509 private key accompanying public key certificates, protected by symmetrical password
|PKIX			|Internet X.509 Public Key Infrastructure
|RSA			|Rivest Shamir Adleman - an algorithm for public-key cryptography
|SCA			|Signature Creation Application
|SCD			|Signature Creation Device
|SME			|Subject Matter Expert
|SMO			|Stakeholder Management Office (CEF)
|SOAP			|Simple Object Access Protocol
|SSCD			|Secure Signature-Creation Device
|SVA			|Signature Validation Application
|TL				|Trusted List
|TLManager		|Application for managing trusted lists.
|TSA			|Time Stamping Authority
|TSL			|Trust-service Status List
|TSP			|Time Stamp Protocol
|TSP			|Trusted Service Provider
|TST			|Time-Stamp Token
|UCF			|Universal Container Format
|URI			|Uniform Resource Identifier
|WSDL			|Web Services Description Language
|WYSIWYS		|What you see is what you sign
|XAdES			|XML Advanced Electronic Signatures
|XML			|Extensible Markup Language
|ZIP			|File format used for data compression and archiving
|=======================

=== References

[cols=4]
|=======================
|Ref.			|Title																			|Reference					|Version
|[[R01]]	R01	|ESI - XAdES digital signatures													|ETSI EN 319 132 part 1-2	|1.0.0
|[[R02]]	R02	|ESI - CAdES digital signatures													|ETSI EN 319 122 part 1-2	|1.1.1
|[[R03]]	R03	|ESI - PAdES digital signatures													|ETSI EN 319 142 part 1-2	|1.1.1
|[[R04]]	R04	|ESI - Associated Signature Containers (ASiC)									|ETSI EN 319 162 part 1-2	|1.1.1
|[[R05]]	R05	|Document management - Portable document format - Part 1: PDF 1.7				|ISO 32000-1				|1
|[[R06]]	R06	|Directive 1999/93/EC of the European Parliament and of the Council of 13 December 1999 on a Community framework for electronic signatures.	|DIRECTIVE 1999/93/EC	|
|[[R07]]	R07	|Internet X.509 Public Key Infrastructure - Time-Stamp Protocol (TSP)			|RFC 3161					|
|[[R08]]	R08	|ESI - Procedures for Creation and Validation of AdES Digital Signatures		|ETSI EN 319 102-1			|1.1.1
|[[R09]]	R09	|ESI - Signature validation policy for European qualified electronic signatures/seals using trusted lists		|ETSI TS 119 172-4			|draft
|[[R10]]	R10	|ESI - Trusted Lists															|ETSI TS 119 612		|2.1.1
|[[R11]]	R11	|eIDAS Regulation No 910/2014													|910/2014/EU			|


|=======================

=== Useful links

 * https://ec.europa.eu/cefdigital/wiki/display/CEFDIGITAL/eSignature[CEF Digital]
 * https://webgate.ec.europa.eu/tl-browser/#/[TL Browser]
 * https://github.com/esig/dss[Source code (GitHub)]
 * https://ec.europa.eu/cefdigital/code/projects/ESIG/repos/dss/browse[Source code (EC Bitbucket)]
 * https://ec.europa.eu/cefdigital/code/projects/ESIG/repos/dss-demos/browse[Source code demonstrations (EC Bitbucket)]
 * https://ec.europa.eu/cefdigital/tracker/projects/DSS/issues[Report an issue (EC Jira)]
 * https://esig-dss.atlassian.net/projects/DSS[Old Jira] 

== General framework structure

DSS framework is a multi-modules project which can be builded with Maven.

You can easily download them with the following Maven repository : 

[source,xml]
----
<repository>
  <id>cefdigital</id>
  <name>cefdigital</name>
  <url>https://ec.europa.eu/cefdigital/artifact/content/repositories/esignaturedss/</url>
</repository>
----

[horizontal]
dss-model:: Data model used in almost every modules.
dss-token:: Token definitions and implementations for MS CAPI, PKCS#11, PKCS#12.
dss-document:: Common module to sign and validate document. This module doen't contain any implementation.
dss-asic-common:: Common code which is shared between dss-asic-xades and dss-asic-cades.
dss-asic-cades:: Implementation of the ASiC-S and ASiC-E signature, extension and validation based on CAdES signatures.
dss-asic-xades:: Implementation of the ASiC-S and ASiC-E signature, extension and validation based on XAdES signatures.
dss-cades:: Implementation of the CAdES signature, extension and validation.
dss-pades:: Common code which is shared between dss-pades-pdfbox and dss-pades-openpdf.
dss-pades-pdfbox:: Implementation of the PAdES signature, extension and validation with https://pdfbox.apache.org/[PDFBox].
dss-pades-openpdf:: Implementation of the PAdES signature, extension and validation with https://github.com/LibrePDF/OpenPDF[OpenPDF (fork of iText)].
dss-xades:: Implementation of the XAdES signature, extension and validation.
dss-spi:: Interfaces, util classes to manipulate ASN1, compute digests,... 
dss-service:: Implementations to communicate with online resources (TSP, CRL, OCSP). 
dss-crl-parser:: API to validate CRLs and retrieve revocation data
dss-crl-parser-stream:: Implementation of dss-crl-parser which streams the CRL (experimental).
dss-crl-parser-x509crl:: Implementation of dss-crl-parser which uses the java object X509CRL.
dss-tsl-validation:: Module which allows to load / parse / validate LOTL and TSLs.
validation-policy:: Business of the signature's validation (ETSI EN 319 102).
dss-rest:: REST webservices to sign (getDataToSign, signDocument methods) and extend a signature.
dss-rest-client:: Client for the REST webservices.
dss-soap:: SOAP webservices to sign (getDataToSign, signDocument methods) and extend a signature.
dss-soap-client:: Client for the SOAP webservices.
dss-validation-rest:: REST webservices to validate a signature.
dss-validation-rest-client:: Client for the REST webservices.
dss-validation-soap:: SOAP webservices to validate a signature.
dss-validation-soap-client:: Client for the SOAP webservices.
dss-remote-services:: Common code between dss-rest and dss-soap.
dss-server-signing-common:: Common code for server signing
dss-server-signing-rest:: REST webservice for server signing
dss-server-signing-rest-client:: REST client for server signing 
dss-server-signing-soap:: SOAP webservice for server signing
dss-server-signing-soap-client:: SOAP client for server signing
sscd-mocca-adapter:: Implementation for MOCCA token.
dss-policy-jaxb:: JAXB model of the validation policy.
dss-diagnostic-jaxb:: JAXB model of the diagnostic data.
dss-simple-report-jaxb:: JAXB model of the simple report.
dss-detailed-report-jaxb:: JAXB model of the detailed report.
dss-reports:: Wrappers to easily manipulate the reports JAXB models (diagnostic-data, simple-report, detailed-report).
dss-tsl-jaxb:: JAXB model of the TSL.
dss-utils:: API with utility methods for String, Collection, I/O,...
dss-utils-apache-commons:: Implementation of dss-utils with Apache Commons libraries
dss-utils-google-guava:: Implementation of dss-utils with Google Guava
dss-test:: Mocks and util classes for unit tests.
dss-cookbook:: Samples and documentation of DSS used to generate this documentation.

=== DSS Utils

The module dss-utils offers an interface with utility methods to operate on String, Collection, I/O,... DSS framework provides two different implementations with the same behavior : 

 * dss-utils-apache-commons : this module uses Apache Commons libraries (commons-lang3, commons-collection4, commons-io and commons-codec);
 * dss-utils-google-guava : this module only requires Google Guava (recommended on Android).

If your integration include dss-utils, you will need to select an implementation.

=== DSS CRL Parser

DSS contains two ways to parse/validate a CRL and to retrieve revocation data. An alternative to the X509CRL java object was developed to face memory issues in case of large CRLs. The X509CRL object fully loads the CRL in memory and can cause OutOfMemoryError.

 * dss-crl-parser-x509crl : this module uses the X509CRL java object.
 * dss-crl-parser-streams : this module offers an alternative with a CRL streaming (experimental).
 
If your integration require dss-crl-parser, you will need to choose your implementation.

=== DSS PAdES

Since the version 5.4, DSS allows to generate/extend/validate PAdES signatures with two different frameworks : PDFBox and OpenPDF (fork of iText). The dss-pades module only contains the common code and requires an underlying implementation : 
 
 * dss-pades-pdfbox
 * dss-pades-openpdf

DSS permits to override the visible signature generation with these interfaces : 

 * eu.europa.esig.dss.pdf.IPdfObjFactory
 * eu.europa.esig.dss.pdf.visible.SignatureDrawerFactory (selects the SignatureDrawer depending of the SignatureImageParameters content)
 * eu.europa.esig.dss.pdf.visible.SignatureDrawer

A new instance of the IPdfObjFactory can be created with its own SignatureDrawerFactory and injected in the PdfObjFactory.setInstance(IPdfObjFactory).

== Available demonstrations

With the framework, some demonstrations are provided.

[horizontal]
dss-standalone-app:: Standalone application which allows to sign a document with different formats and tokens (JavaFX).
dss-standalone-app-package:: Packaging module for dss-standalone-app.
dss-demo-webapp:: Demonstration web application which presents a part of the DSS possibilities.
dss-demo-bundle:: Packaging module for dss-demo-webapp.

WARNING: The demonstrations use a simulated timestamp service (Mock) so that is not recommended for a production usage.

== Signature's profile simplification

The different formats of the digital signature make possible to cover a wide range of real live cases of use of this technique. Thus we distinguish the following formats: XAdES, CAdES, PAdES and ASIC. To each one of them a specific standard is dedicated. The wide variety of options, settings and versions of the standards makes their interoperability very difficult. This is the main reason for which new standards commonly called "baseline profiles" were published. Their goal is to limit the number of options and variants thereby making possible a better interoperability between different actors.

In general can be said that for each format of the digital signature the number of security levels defined in the new standards has been reduced. Below is a comparative table of old and new levels for each format of the signature:

[cols=6]
|=======================
2+|XAdES				  2+|CAdES				  2+|PAdES
|STANDARD 		|BASELINE	|STANDARD 	|BASELINE 	|STANDARD	|BASELINE
|XAdES-BES 		.2+^.^|XAdES-B	|CAdES-BES 	.2+^.^|CAdES-B 	|PAdES-BES 	.2+^.^|PAdES-B
|XAdES-EPES					|CAdES-EPES	 			|PAdES-EPES 
|XAdES-T 		|XAdES-T	|CAdES-T 	|CAdES-T 	|PAdES-T 	|PAdES-T
|XAdES-XL 		|XAdES-LT	|CAdES-XL 	|CAdES-LT 	|PAdES-XL 	|PAdES-LT
|XAdES-A 		|XAdES-LTA	|CAdES-A 	|CAdES-LTA 	|PAdES-LTV 	|PAdES-LTA
|=======================

Note that the new version (v4) of the DSS framework is compatible with the baseline profiles, it is no longer possible to use the standard profiles for signing purpose. The validation of the signature still takes into account the old profiles.

== The XML Signature (XAdES)

The simplest way to address the digital signature passes through the XAdES format. Indeed, it allows to visualize the content of the signature with a simple text editor. Thus it becomes much easier to make the connection between theoretical concepts and their implementation. Before embarking on the use of the DSS framework, it is advisable to read the following documents:

 * XAdES Specifications (cf. <<R01>>)

After reading these documents, it is clear that:

 * To electronically sign a document, a signing certificate (that proves the signer's identity) and the access to its associated private key is needed. 
 * To electronically validate a signed document the signer's certificate containing the public key is needed. To give a more colourful example: when a digitally signed document is sent to a given person or organization in order to be validated, the certificate with the public key used to create the signature must also be provided.

===	XAdES Profiles

The new ETSI standard defines four conformance levels to address the growing need to protect the validity of the signature in time. Henceforth to denote the level of the signature the word "level" will be used. Follows the list of levels defined in the standard:

 * XAdES-BASELINE-*B*: _Basic Electronic Signature_
The lowest and simplest version just containing the SignedInfo, SignatureValue, KeyInfo and SignedProperties. This level combines the old -BES and -EPES levels.
This form extends the definition of an electronic signature to conform to the identified signature policy.
 * XAdES-BASELINE-*T*: _Signature with a timestamp_
A timestamp regarding the time of signing is added to protect against repudiation.
 * XAdES-BASELINE-*LT*: _Signature with Long Term Data_
Certificates and revocation data are embedded to allow verification in future even if their original source is not available. This level is equivalent to the old -XL level.
 * XAdES-BASELINE-*LTA*: _Signature with Long Term Data and Archive timestamp_
By using periodical timestamping (e.g. each year) compromising is prevented which could be caused by weakening previous signatures during a long-time storage period. This level is equivalent to the old -A level.

NOTE: Old levels: -BES, -EPES, -C, -X, -XL, -A are not supported any more when signing.

==== XAdES-BASELINE-B

To start, let's take a simple XML document:

[[xml_example.xml]]
[source,xml]
.xml_example.xml
----
<?xml version="1.0"?>
<test>Hello World !</test>
----

Since this is an XML document, we will use the XAdES signature and more particularly XAdES-BASELINE-B level, which is the lowest level of protection: just satisfying Directive (cf. <<R06>>) legal requirements for advanced signature. The normal process of signing wants to sign first with the level -B or level-T, and then later when it becomes necessary to complete the signature with superior levels. However, the framework allows signing directly with any level.
When signing data, the resulting signature needs to be linked with the data to which it applies. This can be done either by creating a data set which combines the signature and the data (e.g. by enveloping the data with the signature or including a signature element in the data set) or placing the signature in a separate resource and having some external means for associating the signature with the data. So, we need to define the packaging of the signature, namely ENVELOPED, ENVELOPING, DETACHED or INTERNALLY-DETACHED.
 
 * *ENVELOPED :* when the signature applies to data that surround the rest of the document;
 * *ENVELOPING :* when the signed data form a sub-element of the signature itself;
 ** Base64 encoded binaries;
 ** Embed XML object(s);
 ** Embed https://www.w3.org/TR/xmldsig-core/#sec-o-Manifest[Manifest] object(s)
 * *DETACHED :* when the signature relates to the external resource(s) separated from it.
 * *INTERNALLY-DETACHED :* when the signature and the related signed data are both included in a parent element (only XML).

For our example, we will use ENVELOPED packaging.

The DSS framework uses 3 atomic steps to sign a document :

. Compute the digest to be signed;
. Sign the digest; 
. Sign the document (add the signed digest).

The DSS fully manages the steps 1 and 3. We need to specify how to do the signature operation. DSS offers some implementations in the dss-token module

To write our Java code, we still need to specify the type of KeyStore to use for signing our document, more simply, where the private key can be found. In the package "eu.europa.esig.dss.token", we can choose between different connection tokens :

 * *Pkcs11SignatureToken :* allows to communicate with SmartCards with the PKCS#11 interface. It requires some installed drivers (dll, sso,...) 
 * *Pkcs12SignatureToken :* allows to sign with a PKC#12 keystore (.p12 file).
 * *MSCAPISignatureToken :* handles the signature with MS CAPI (the Microsoft interface to communicate with SmartCards).
 * *JKSSignatureToken :* allows to sign with a Java Key Store (.jks file).

NOTE: The DSS also provides the support for MOCCA framework to communicate with the Smartcard with PC/SC, but it involves the installation of the MOCCA and IAIK libraries.

To know more about the use of the different signature tokens, please consult "Management of Signature Tokens" chapter.

In our example the class: "Pkcs12SignatureToken" will be used. A file in PKCS#12 format must be provided to the constructor of the class. It contains an X.509 private key accompanying the public key certificate and protected by symmetrical password. The certification chain can also be included in this file. It is possible to generate dummy certificates and their chains with OpenSSL. Please visit http://www.openssl.org/ for more details.

This is the complete code that allows you to sign our XML document.

[source,java,indent=0]
.Create a XAdES signature
----
include::{sourcetestdir}/eu/europa/esig/dss/cookbook/example/sign/SignXmlXadesBTest.java[tags=demo]
----

What you may notice is that to sign a document we need to:

 * Create an object based on SignatureParameters class. The number of specified parameters depends on the type of signature. Generally, the number of specified parameters depends on the profile of signature. This object also defines some default parameters.
 * Choose the profile, packaging, signature digest algorithm.
 * Indicate the private key entry to be used.
 * Instantiate the adequate signature service.
 * Carry out the signature process.
 
The encryption algorithm is determined by the private key and therefore cannot be compelled by the setter of the signature parameters object. It will cause an inconsistency in the signature making its validation impossible. This setter can be used in a particular context where the signing process is distributed on different machines and the private key is known only to the signature value creation process. See clause "Signing process" for more information.
In the case where the private key entry object is not available, it is possible to choose the signing certificate and its certificate chain as in the following example:

[source,java,indent=0]
----
include::{sourcetestdir}/eu/europa/esig/dss/cookbook/example/snippets/Snippets.java[tags=demoCertificateChain]
----

Integrating the certificate chain in the signature simplifies the build of a prospective certificate chain during the validation process.

By default the framework uses the current date time to set the signing date, but in the case where it is necessary to indicate the different time it is possible to use the setter "setSigningDate(Date)" as in the example:

[source,java,indent=0]
----
include::{sourcetestdir}/eu/europa/esig/dss/cookbook/example/snippets/Snippets.java[tags=demoSigningDate]
----

When the specific service is instantiated a certificate verifier must be set. This object is used to provide four different sources of information:

 * the source of trusted certificates (based on the trusted list(s) specific to the context);
 * the source of intermediate certificates used to build the certificate chain till the trust anchor. This source is only needed when these certificates are not included in the signature itself;
 * the source of OCSP;
 * the source of CRL.
 
In the current implementation this object is only used when profile -LT or -LTA are created. 

===== Signing process

Once the parameters of the signature were identified the service object itself must be created. The service used will depend on the type of document to sign. In our case it is an XML file, so we will instantiate a XAdES service. The process of signing takes place in three stages. The first is the "getDataToSign ()" method call, passing as a parameter the document to be signed and the previously selected settings. This step returns the data which is going to be digested and encrypted. In our case it corresponds to the SignedInfo XMLDSig element.  

[source,java,indent=0]
----
include::{sourcetestdir}/eu/europa/esig/dss/cookbook/example/snippets/Snippets.java[tags=demoSigningProcessGetDataToSign]
----

The next step is a call to the function "sign()" which is invoked on the object token representing the KeyStore and not on the service. This method takes three parameters. The first is the array of bytes that must be signed. It is obtained by the previous method invocation. The second is the algorithm used to create the digest. You have the choice between SHA1, SHA256, and SHA512 (this list is not exhaustive). And the last one is the private key entry.

[source,java,indent=0]
----
include::{sourcetestdir}/eu/europa/esig/dss/cookbook/example/snippets/Snippets.java[tags=demoSigningProcessSign]
----

The last step of this process is the integration of the signature value in the signature and linking of that one to the signed document based on the selected packaging method. This is the method "signDocument()" on the service. We must pass to it three parameters: again the document to sign, the signature parameters and the value of the signature obtained in the previous step.

This separation into three steps allows use cases where different environments have their precise responsibilities: specifically the distinction between communicating with the token and executing the business logic.

When the breakdown of this process is not necessary than a simple call to only one method can be done as in the following example:

[source,java,indent=0]
----
include::{sourcetestdir}/eu/europa/esig/dss/cookbook/example/snippets/Snippets.java[tags=demoSigningProcessSignDocument]
----

===== Additional attributes

For this type (XAdES-BASELINE-B) of signature it is possible to identify some additional attributes:

 * SignerRole - contains claimed roles assumed by the signer when creating the signature.
 * SignatureProductionPlace - contains the indication of the purported place where the signer claims to have produced the signature.
 * CommitmentTypeIndication - identifies the commitment undertaken by the signer in signing (a) signed data object(s) in the context of the selected signature policy.
 * AllDataObjectsTimeStamp - each time-stamp token within this property covers the full set of references defined in the Signature's SignedInfo element, excluding references of type "SignedProperties".
 * IndividualDataObjectsTimeStamp - each time-stamp token within this property covers selected signed data objects.

The DSS framework allows to setup the following signed properties: SignerRole, SignatureProductionPlace, CommitmentTypeIndication, AllDataObjectsTimestamp and IndividualDataObjectsTimeStamp.

[[SignXmlXadesBProperties.java]]
[source,java,indent=0]
.XAdES signature with additional signed attributes
----
include::{sourcetestdir}/eu/europa/esig/dss/cookbook/example/sign/SignXmlXadesBPropertiesTest.java[tags=demo]
----

This code adds the following elements into the signature :

include::samples/xades-b-properties.adoc[]

===== Handling signature policy

With the new standards the policy handling is linked to -B level. The old -EPES level is not used anymore by the framework. This does not alter the structure of the old signature but only modifies how to control the process of its creation.

The DSS framework allows you to reference a signature policy, which is a set of rules for the creation and validation of an electronic signature. It includes two kinds of text:
 
 * In human readable form:
It can be assessed to meet the requirements of the legal and contractual context in which it is being applied.

 * In a machine processable form:
To facilitate its automatic processing using the electronic rules.

If no signature policy is identified then the signature may be assumed to have been generated or verified without any policy constraints, and hence may be given no specific legal or contractual significance through the context of a signature policy.

The signer may reference the policy either implicitly or explicitly. An implied policy means the signer follows the rules of the policy but the signature does not indicate which policy. It is assumed the choice of policy is clear from the context in which the signature is used and SignaturePolicyIdentifier element will be empty. When the policy is not implied, the signature contains an ObjectIdentier that uniquely identifies the version of the policy in use. The signature also contains a hash of the policy document to make sure that the signer and verifier agree on the contents of the policy document.

This example demonstrates an implicit policy identifier. To implement this alternative you must set SignaturePolicyId to empty string.

[source,java,indent=0]
.XAdES with implicit policy
----
include::{sourcetestdir}/eu/europa/esig/dss/cookbook/example/sign/SignXmlXadesBImplicitPolicyTest.java[tags=demo]
----

An XML segment will be added to the signature's qualified and signed properties:

include::samples/xades-implicit-policy.adoc[]

The next example demonstrates an explicit policy identifier. This is obtained by setting -B profile signature policy and assigning values to the policy parameters. The Signature Policy Identifier is a URI or OID  that uniquely identifies the version of the policy document. The signature will contain the identifier of the hash algorithm and the hash value of the policy document. The DSS framework does not automatically calculate the hash value; it is to the developer to proceed with the calculation using for example java.security.MessageDigest class (rt.jar). It is important to keep the policy file intact in order to keep the hash constant. It would be wise to make the policy file read-only. See also chapter 7 for further information.

[source,java,indent=0]
.XAdES with explicit policy
----
include::{sourcetestdir}/eu/europa/esig/dss/cookbook/example/sign/SignXmlXadesBExplicitPolicyTest.java[tags=demo]
----

The following XML segment will be added to the signature qualified & signed properties (<QualifyingProperties><SignedProperties>):

include::samples/xades-explicit-policy.adoc[]

==== XAdES-BASELINE-T

XAdES-BASELINE-T is a signature for which there exists a trusted time associated to the signature. It provides the initial steps towards providing long term validity and more specifically it provides a protection against repudiation. This extension of the signature can be created as well during the generation process as validation process. However, the case when these validation data are not added during the generation process should no longer occur. The XAdES-BASELINE-T trusted time indications must be created before the signing certificate has been revoked or expired and close to the time that the XAdES signature was produced. The XAdES-BASELINE-T form must be built on a XAdES-BASELINE-B form. The DSS framework allows extending the old -BES and -EPES profiles to the new BASELINE-T profile, indeed there is no difference in the structure of the signature.

To implement this profile of signature you must indicate to the service the TSA source, which delivers from each Timestamp Request a Timestamp Response (RFC 3161 (cf. <<R07>>)) containing tokens. Below is the source code that creates a XAdES-BASELINE-T signature. For our example, we will use the Belgian provider and an instance of OnlineTSPSource (see "TSP Sources" chapter for more details).

[source,java,indent=0]
.Create a XAdES-Baseline-T with an OnlineTSPSource
----
include::{sourcetestdir}/eu/europa/esig/dss/cookbook/example/sign/SignXmlXadesTWithOnlineSourceTest.java[tags=demo]
----

If the timestamp source is not set a NullPointerException is thrown.

The SignatureTimeStamp mandated by the XAdES-T form appears as an unsigned property within the QualifyingProperties:

include::samples/xades-signature-timestamp.adoc[]

==== XAdES-BASELINE-LT

This level has to prove that the certification path was valid, at the time of the validation of the signature, up to a trust point according to the naming constraints and the certificate policy constraints from the "Signature Validation Policy". It will add to the signature the CertificateValues and RevocationValues unsigned properties. The CertificateValues element contains the full set of certificates that have been used to validate the electronic signature, including the signer's certificate. However, it is not necessary to include one of those certificates, if it is already present in the ds:KeyInfo element of the signature. This is like DSS framework behaves. In order to find a list of all the certificates and the list of all revocation data, an automatic process of signature validation is executed. To carry out this process an object called CertificateVerifier must be passed to the service. The implementer must set some of its properties like par example the source of trusted certificates. The code below shows how to use the default parameters with this object. Please refer to "The Signature Validation" chapter to have the further information. It also includes an example of how to implement this level of signature:

[[SignXmlXadesLTTest.java]]
[source,java,indent=0]
.SignXmlXadesLTTest.java
----
include::{sourcetestdir}/eu/europa/esig/dss/cookbook/example/sign/SignXmlXadesLTTest.java[tags=demo]
----

The following XML segment will be added to the signature qualified and unsigned properties:

include::samples/xades-revocation-data.adoc[]

NOTE: The use of online sources can significantly increase the execution time of the signing process. For testing purpose you can create your own source of data.

In last example the CommonsHttpDataLoader is used to provide the communication layer for HTTP protocol. Each source which need to go through the network to retrieve data need to have this component set.

==== XAdES-BASELINE-LTA

When the cryptographic data becomes weak and the cryptographic functions become vulnerable the auditor should take steps to maintain the validity of the signature. The XAdES-BASELINE-A form uses a simple approach called "archive validation data". It adds additional time-stamps for archiving signatures in a way that they are still protected, but also to be able to prove that the signatures were validated at the time when the used cryptographic algorithms were considered safe. The time-stamping process may be repeated every time the protection used becomes weak. Each time-stamp needs to be affixed before either the signing key or the algorithms used by the TSA are no longer secure. XAdES-A form adds the ArchiveTimestamp element within the UnsignedSignatureProperties and may contain several ArchiveTimestamp elements.

Below is an example of the implementation of this level of signature (but in practice, we will rather extend the signature to this level when there is a risk that the cryptographic functions become vulnerable or when one of certificates arrives to its expiration date):

[source,java]
----
...
parameters.setSignatureLevel(SignatureLevel.XAdES_BASELINE_LTA);
...
----

The following XML segment will be added to the signature qualified and unsigned properties:

include::samples/xades-archive-timestamp.adoc[]

=== Various settings

==== Trust anchor inclusion policy

It is possible to indicate to the framework if the certificate related to the trust anchor should be included to the signature or not. The setter #setTrustAnchorBPPolicy of the BLevelParameters class should be used for this purpose.

This rule applies as follows: when -B level is constructed the trust anchor is not included, when -LT level is constructed the trust anchor is included.

NOTE: when trust anchor baseline profile policy is defined only the certificates previous to the trust anchor are included when -B level is constructed.

=== Multiple signatures

In everyday life, there are many examples where it is necessary to have multiple signatures covering the same document, such as a contract to purchase a vehicle. Independent signatures are parallel signatures where the ordering of the signatures is not important. The computation of these signatures is performed on exactly the same input but using different private keys.

=== The XML Signature Extension (XAdES)

The -B level contains immutable signed properties. Once this level is created, these properties cannot be changed. 

The levels -T/-LT/-LTA add unsigned properties to the signature. This means that the properties of these levels could be added afterwards to any AdES signature. This addition helps to make the signature more resistant to cryptographic attacks on a longer period of time. The extension of the signature is incremental, i.e. when you want to extend the signature to the level -LT the lower level (-T) will also be added. The whole extension process is implemented by reusing components from signature production. To extend a signature we proceed in the same way as in the case of a signature, except that you have to call the function "extendDocument" instead of the "sign" function. Note that when the document is signed with several signatures then they are all extended.

=== XAdES-BASELINE-T

The XAdES-BASELINE-T trusted time indications have to be created before a certificate has been revoked or expired and close to the time that the XAdES signature was produced. It provides a protection against repudiation. The framework adds the timestamp only if there is no timestamp or there is one but the creation of a new extension of the level-T is deliberate (using another TSA). It is not possible to extend a signature which already incorporates higher level as -LT or -LTA. In the theory it would be possible to add another -T level when the signature has already reached level -LT but the framework prevents this operation. Note that if the signed document contains multiple signatures, then all the signatures will be extended to level -T. It is also possible to sign a document directly at level -T. 

Here is an example of creating an extension of type T:

[source,java,indent=0]
.Extend a XAdES signature
----
include::{sourcetestdir}/eu/europa/esig/dss/cookbook/example/sign/ExtendSignXmlXadesBToTTest.java[tags=demo]
----

Here is the result of adding a new extension of type-T to an already existing -T level signature:

include::samples/xades-extend-t-to-t.adoc[]

=== XAdES-BASELINE-LT and -LTA

For these types of extensions, the procedure to follow is the same as the case of the extension of type T. Please refer to the chapter XAdES Profiles (XAdES) to know specific parameters for each level of signature and which must be positioned.

=== XAdES and specific schema version

Some signatures may have been created with an older version of XAdES standard using different schema definition. To take into account the validation of such signatures the class eu.europa.esig.dss.xades.validation.XPathQueryHolder was created. This class includes all XPath queries which are used to explore the elements of the signature. It is now easy to extend this class in order to define specific queries to a given schema. The DSS framework proposes in standard the class eu.europa.esig.dss.xades.validation.XAdES111XPathQueryHolder that defines the XPath queries for the version "http://uri.etsi.org/01903/v1.1.1#" of XAdES standard.

When carrying out the validation process of the signature, the choice of query holder to be used is taken by invoking the method: eu.europa.esig.dss.xades.validation.XPathQueryHolder#canUseThisXPathQueryHolder

This choice is made based on the namespace. If the namespace is: http://uri.etsi.org/01903/v1.3.2# then the default query holder is used, if the namespace is http://uri.etsi.org/01903/v1.1.1# the XAdES111XPathQueryHolder is used. The element used to choose the namespace is "QualifyingProperties".

To implement another query holder the class XPathQueryHolder must be extended, new XPath queries defined and the method canUseThisXPathQueryHolder overridden.

In case there is a need to use only a specific query holder the following steps should be followed:

 * Call: eu.europa.esig.dss.xades.validation.XMLDocumentValidator#clearQueryHolders
 * Call: eu.europa.esig.dss.xades.validation.XMLDocumentValidator#addXPathQueryHolder and pass the specific query holder

== The signature validation

Generally and following ETSI standard, the validation process of an electronic signature must provide one of the three following status: TOTAL-FAILED, TOTAL-PASSED or INDETERMINATE. A TOTAL-PASSED response indicates that the signature has passed verification and it complies with the signature validation policy. An TOTAL_FAILED response indicates that either the signature format is incorrect or that the digital signature value fails verification. An INDETERMINATE validation response indicates that the format and digital signature verifications have not failed but there is insufficient information to determine if the electronic signature is valid. For each of the validation checks, the validation process must provide information justifying the reasons for the resulting status indication as a result of the check against the applicable constraints. In addition, the ETSI standard defines a consistent and accurate way for justifying statuses under a set of sub-indications.

===	Validation Process

Since version 4.7 of the DSS framework the validation process is based on the latest ETSI standard <<R08>>. It is driven by the validation policy and allows long term signature validation. It not only verifies the existence of certain data and their validity, but it also checks the temporal dependences between these elements. The signature check is done following basic building blocks. On the simplified diagram below, showing the process of the signature validation, you can follow the relationships between each building block which represents a logic set of checks used in validation process.

image::sig_validation_process.jpg[]

Note that the current version of the framework during the validation process does not indicate what part of document was signed. However, in the case of the XAdES signature XPath transformations present in the signature will be applied, in the case of CAdES or PAdES signature the whole document must be signed.

At the end of the validation process three reports are created. They contain the different details level concerning the validation result. They provide three kinds of visions of validation process: macroscopic, microscopic and input data. For more information about these reports, please refer to "Simple Report" chapter.

Below is the simplest example of the validation of the signature of a document. The first thing to do is instantiating an object named validator, which orchestrates the verification of the different rules. To perform this it is necessary to invoke a static method fromDocument() on the abstract class SignedDocumentValidator. This method returns the object in question whose type is chosen dynamically based on the type of source document. The DSS framework provides five types of validators:
 
 * XMLDocumentValidator,
 * CMSDocumentValidator,
 * PDFDocumentValidator,
 * ASiCContainerWithXAdESValidator,
 * ASiCContainerWithCAdESValidator.

The next step is to create an object that will check the status of a certificate using the Trusted List model (see "Trusted Lists of Certification Service Provider" for more information). In our example, this object is instantiated from the TrustedListCertificateVerifier class. In turn, this object needs an OCSP and/or CRL source and a TSL source (which defines how the certificates are retrieved from the Trusted Lists). See chapter "Management of CRL and OCSP Sources" for more information concerning sources.

[source,java,indent=0]
.Validation of a signature
----
include::{sourcetestdir}/eu/europa/esig/dss/cookbook/example/validate/ValidateSignedXmlXadesBTest.java[tags=demo]
----

NOTE: When using the TrustedListsCertificateSource class, for performance reasons, consider creating a single instance of this class and initialize it only once.

NOTE: In general, the signature must cover the entire document so that the DSS framework can validate it. However, for example in the case of a XAdES signature, some transformations can be applied on the XML document. They can include operations such as canonicalization, encoding/decoding, XSLT, XPath, XML schema validation, or XInclude. XPath transforms permit the signer to derive an XML document that omits portions of the source document. Consequently those excluded portions can change without affecting signature validity. 

===	EU Trusted Lists of Certification Service Providers

On 16 October 2009 the European Commission adopted a Decision setting out measures facilitating the use of procedures by electronic means through the "points of single contact" under the Services Directive. One of the measures adopted by the Decision consisted in the obligation for Member States to establish and publish by 28.12.2009 their Trusted List of supervised/accredited certification service providers issuing qualified certificates to the public. The objective of this obligation is to enhance cross-border use of electronic signatures by increasing trust in electronic signatures originating from other Member States. The Decision was updated several times since 16.10.2009; the last amendment was made on 01.02.2014. The consolidated version is available here for information.

In order to allow access to the trusted lists of all Member States in an easy manner, the European Commission has published a central list with links to national "trusted lists". This central list will now be designated in the document under the abbreviation LOTL.

The LOTL is published by the EU at the following URL : https://ec.europa.eu/information_society/policy/esignature/trusted-list/tl-mp.xml. This XML file contains the list of the trusted list. This file must be signed by an allowed certificate. To know who has the permission to sign / publish the LOTL, we need to refer to the Official Journal Of the Union (http://eur-lex.europa.eu/legal-content/EN/TXT/?uri=uriserv:OJ.C_.2016.233.01.0001.01.ENG).

The signature format of the LOTL and TL should be XAdES-BASELINE-B. If the LOTL signature is valid, its content can be trusted. The LOTL contains for each country some information : urls of the XML/PDF files, the allowed certificates to sign, ...

So, we trusted the LOTL, we can process each trusted list. If they are valid, we can trust the service providers and its certificates.

To build the source of trust, DSS requires : 

 * the LOTL url (XML); 
 * the LOTL country code;
 * a trust store which contains allowed certificates (extracted from the OJ).
 
Below, you can find a complete example to load the LOTL and its linked TLs.
 
[source,java,indent=0]
.Configuration to load the LOTL and related TLs
----
include::{sourcetestdir}/eu/europa/esig/dss/cookbook/example/sources/LOTLLoadingTest.java[tags=demo]
----

The TrustedListsCertificateSource is updated with the trusted certificates. 

To generate the trust store, there's an utility class CreateKeyStoreApp in the dss-cookbook module.

==== Non-European trusted lists support

Additionally, DSS can load external trusted lists. These trusted lists are checked against their trust store (keystore which contains the authorized TL signers).

[source,java,indent=0]
.Handling of Non-European trusted list(s)
----
include::{sourcetestdir}/eu/europa/esig/dss/cookbook/example/sources/LOTLLoadingTest.java[tags=additionalTL]
----
 
===	Validation Result Materials

The result of the validation process consists of three elements: 

 * the simple report, 
 * the detailed report and,
 * the diagnostic data.
 
All these reports are encoded using XML, which allows the implementer to easily manipulate and extract information for further analysis. For each report, XML Schema and JaxB model are available as maven dependencies.

DSS also provides XSLT to able to generate PDF or HTML reports (simple and detailed reports).

You will find below a detailed description of each of these elements.

==== Simple Report 

This is a sample of the simple validation report.

.Simple Report 
include::samples/simple-report-example.adoc[]

The result of the validation process is based on very complex rules. The purpose of this report is to make as simple as possible the information while keeping the most important elements. Thus the end user can, at a glance, have a synthetic view of the validation. To build this report the framework uses some simple rules and the detailed report as input.

==== Detailed Report

This is a sample of the detailed validation report. Its structure is based on the ETSI standard <<R08>> and is built around Basic Building Blocks, Basic Validation Data, Timestamp Validation Data, AdES-T Validation Data and Long Term Validation Data. Some segments were deleted to make reading easier. They are marked by three dots:

.Detailed Report 
include::samples/detailed-report-example.adoc[]

For example the Basic Building Blocks are divided into seven elements:

 * FC - Format Checking
 * ISC - Identification of the Signing Certificate
 * VCI - Validation Context Initialization
 * RFC - Revocation Freshness Checker
 * XCV - X.509 certificate validation
 * CV - Cryptographic Verification
 * SAV - Signature Acceptance Validation
 
The following additional elements also can be execute in case of validation in the past : 

 * PCV - Past Certificate Validation
 * VTS - Validation Time Sliding process
 * POE extraction - Proof Of Existence extraction 
 * PSV - Past Signature Validation
 
Each block contains a number of rules that are executed sequentially. The rules are driven by the constraints defined in the validation policy. The result of each rule is OK or NOT OK. The process is stopped when the first rule fails. Each block also contains a conclusion. If all rules are met then the conclusion node indicates PASSED. Otherwise FAILED or INDETERMINATE indication is returned depending on the ETSI standard definition. 

==== Diagnostic Data

This is a data set constructed from the information contained in the signature itself, but also from information retrieved dynamically as revocation data and information extrapolated as the mathematical validity of a signature. All this information is independent of the applied validation policy. Two different validation policies applied to the same diagnostic data can lead to different results.

This is an example of the diagnostic data for a PAdES signature. Certain fields and certain values were trimmed or deleted to make reading easier:

.Diagnostic Data
include::samples/diagnostic-data-example.adoc[]

=== Customised Validation Policy

The validation process may be driven by a set of constraints that are contained in the XML file constraint.xml.

.constraint.xml (default policy is provided in validation-policy module)
include::samples/constraint.adoc[]

== CAdES signature (CMS)

To familiarise yourself with this type of signature it is advisable to read the following document:

* CAdES Specifications (cf. <<R02>>)

To implement this form of signature you can use the XAdES examples. You only need to instantiate the CAdES object service and change the SignatureLevel parameter value. Below is an example of the CAdES-Baseline-B signature:

[source,java,indent=0]
.Signing a file with CAdES
----
include::{sourcetestdir}/eu/europa/esig/dss/cookbook/example/sign/SignXmlCadesBTest.java[tags=demo]
----

== PAdES signature (PDF)

The standard ISO 32000-1 (cf. <<R05>>) allows defining a file format for portable electronic documents. It is based on PDF 1.7 of Adobe Systems. Concerning the digital signature it supports three operations: 

 * Adding a digital signature to a document,
 * Providing a placeholder field for signatures,
 * Checking signatures for validity.

PAdES defines eight different profiles to be used with advanced electronic signature in the meaning of European Union Directive 1999/93/EC (cf. <<R06>>):

 * PAdES Basic - PDF signature as specified in ISO 32000-1 (cf. <<R05>>). The profile is specified in ETSI EN 319 142 (cf. <<R03>>).
 * PAdES-BES Profile - based upon CAdES-BES as specified in ETSI EN 319 122 (cf. <<R02>>) with the option of a signature time-stamp (CAdES-T).
 * PAdES-EPES profile - based upon CAdES-EPES as specified in ETSI EN 319 122 (cf. <<R02>>). This profile is the same as the PAdES - BES with the addition of a signature policy identifier and optionally a commitment type indication.
 * PAdES-LTV Profile - This profile supports the long term validation of PDF Signatures and can be used in conjunction with the above-mentioned profiles.
 * Four other PAdES profiles for XML Content.

To familiarise yourself with this type of signature it is advisable to read the documents referenced above.

Below is an example of code to perform a PAdES-BASELINE-B type signature:

[source,java,indent=0]
.Signing a PDF file with PAdES
----
include::{sourcetestdir}/eu/europa/esig/dss/cookbook/example/sign/SignPdfPadesBTest.java[tags=demo]
----

To add the timestamp to the signature (PAdES-T or LTA), please provide TSP source to the service.

To create PAdES-BASELINE-B level with additional options: signature policy identifier and optionally a commitment type indication, please observe the following example in code 5.

All these parameters are optional. 

 * *SignaturePolicyOID :* The string representation of the OID of the signature policy to use when signing.

 * *SignaturePolicyHashValue :* The value of the hash of the signature policy, computed the same way as in clause 5.2.9 of CAdES (ETSI EN 319 122 (cf. <<R02>>)).

 * *SignaturePolicyHashAlgorithm :* The hash function used to compute the value of the SignaturePolicyHashValue entry. Entries must be represented the same way as in table 257 of ISO 32000-1 (cf. <<R05>>).

 * *SignaturePolicyCommitmentType :* If the SignaturePolicyOID is present, this array defines the commitment types that can be used within the signature policy. An empty string can be used to indicate the default commitment type.

If the SignaturePolicyOID is absent, the three other fields defined above will be ignored. If the SignaturePolicyOID is present but the SignaturePolicyCommitmentType is absent, all commitments defined by the signature policy will be used.

The extension of a signature of the level PAdES-BASELINE-B up to PAdES-BASELINE-LTA profile will add the following features:

 * Addition of validation data to an existing PDF document which may be used to validate earlier signatures within the document (including PDF signatures and time-stamp signatures). 
 * Addition of a document time-stamp which protects the existing document and any validation data. 
 * Further validation data and document time-stamp may be added to a document over time to maintain its authenticity and integrity.

=== PAdES Visible Signature

The framework also allows to create PDF files with visible signature as specified in ETSI EN 319 142 (cf. <<R03>>). In the SignatureParameters object, there's a special attribute named ImageParameters. This parameter let you custom the visual signature (with text, with image or with image and text).
Below is an example of code to perform a PADES-BASELINE-B type signature with a visible signature:

[source,java,indent=0]
.Add a visible signature to a PDF document
----
include::{sourcetestdir}/eu/europa/esig/dss/cookbook/example/sign/SignPdfPadesBVisibleTest.java[tags=demo]
----

Additionally, DSS also allows to insert a visible signature in an existing field : 

[source,java,indent=0]
----
include::{sourcetestdir}/eu/europa/esig/dss/cookbook/example/snippets/Snippets.java[tags=select-pdf-signature-field]
----

== ASiC signature (containers)

When creating a digital signature, the user must choose between different packaging elements, namely enveloping, enveloped or detached. This choice is not obvious, because in one case the signature will alter the signed document and in the other case it is possible to lose the association between the signed document and its signature. That's where the standard ETSI EN 319 162 (cf. <<R04>>) offers a standardized use of container forms to establish a common way for associating data objects with advanced signatures or time-stamp tokens.

A number of application environments use ZIP based container formats to package sets of files together with meta-information. ASiC technical specification is designed to operate with a range of such ZIP based application environments. Rather than enforcing a single packaging structure, ASiC describes how these package formats can be used to associate advanced electronic signatures with any data objects.

The standard defines two types of containers; the first (ASiC-S) allows you to associate one or more signatures with a single data element. In this case the structure of the signature can be based (in a general way) on a single CAdES signature or on multiple XAdES signatures or finally on a single TST; the second is an extended container (ASiC-E) that includes multiple data objects. Each data object may be signed by one or more signatures which structure is similar to ASiC-S. This second type of container is compatible with OCF, UCF and ODF formats.

For the moment the DSS framework has some restrictions on the containers you can generate, depending on the input file. If the input file is already an ASiC container, the output container must be the same type of container based on the same type of signature. If the input is any other file, the output does not have any restriction.

|===
|Input |Output

|ASiC-S CAdES
|ASiC-S CAdES

|ASiC-S XAdES
|ASiC-S XAdES

|ASiC-E CAdES
|ASiC-E CAdES

|ASiC-E XAdES
|ASiC-E XAdES

|Binary
|ASiC-S CAdES, ASiC-S XAdES, ASiC-E CAdES, ASiC-E XAdES
|===

This is an example of the source code for signing a document using ASiCS-S based on XAdES-B:

[source,java,indent=0]
.Sign a file within an ASiC-S container
----
include::{sourcetestdir}/eu/europa/esig/dss/cookbook/example/sign/SignOneFileWithASiCSBTest.java[tags=demo]
----

This is another example of the source code for signing multiple documents using ASiCS-E based on CAdES:

[source,java,indent=0]
.Sign multiple files within an ASiC-E container
----
include::{sourcetestdir}/eu/europa/esig/dss/cookbook/example/sign/SignMultipleDocumentsWithASiCSEWithCAdESTest.java[tags=demo]
----

Please note that you need to pass only few parameters to the service. Other parameters, although are positioned, will be overwritten by the internal implementation of the service. Therefore, the obtained signature is always based on CAdES and of DETACHED packaging.

It is also possible with the framework DSS to make an extension of an ASiC container to the level XAdES-BASELINE-T or -LT.

== Available implementations of DSSDocument

DSS allows to create different kinds of DSSDocument : 

 * InMemoryDocument : fully loads in memory. This type of DSSDocument can be instantiated with an array of bytes, an InputStream,...
 * FileDocument : refers an existing File
 * DigestDocument : only contains pre-computed digest values for a given document. That allows to avoid sending the full document (detached signatures). 
 
[source,java,indent=0]
.DigestDocument
----
include::{sourcetestdir}/eu/europa/esig/dss/cookbook/example/sources/DigestDocumentTest.java[tags=demo]
----

== Management of signature tokens

The DSS framework is able to create signatures from PKCS#11, PKCS#12 and MS CAPI. Java 6 is inherently capable of communicating with these kinds of KeyStores. To be independent of the signing media, DSS framework uses an interface named SignatureTokenConnection to manage different implementations of the signing process. The base implementation is able to sign a stream of the data in one step. That means that all the data to be signed needs to be sent to the SSCD. This is the case for MS CAPI. As to the PKCS#11 and PKCS#12, which give to the developer a finer control in the signature operation, the DSS framework implements the AsyncSignatureTokenConnection abstract class that permits to execute the digest operation and signature operation in two different threads or even two different hardwares.

This design permits also other card providers/adopters to create own implementations. For example, this can be used for a direct connection to the Smartcard through Java 6 PC/SC.

=== PKCS#11

PKCS#11 is widely used to access smart cards and HSMs. Most commercial software uses PKCS#11 to access the signature key of the CA or to enrol user certificates. In the DSS framework, this standard is encapsulated in the class Pkcs11SignatureToken.

[source,java,indent=0]
.Pkcs11SignatureToken usage
----
include::{sourcetestdir}/eu/europa/esig/dss/cookbook/example/snippets/PKCS11Snippet.java[tags=demo]
----

=== PKCS#12
 
This standard defines a file format commonly used to store the private key and corresponding public key certificate protecting them by password. 

In order to use this format with the DSS framework you have to go through the class Pkcs12SignatureToken. 

[source,java,indent=0]
.Pkcs12SignatureToken usage
----
include::{sourcetestdir}/eu/europa/esig/dss/cookbook/example/snippets/PKCS12Snippet.java[tags=demo]
----
 
=== MS CAPI

If the middleware for communicating with an SSDC provides a CSP based on MS CAPI specification, then to sign the documents you can use MSCAPISignatureToken class.

[source,java,indent=0]
.MSCAPISignatureToken usage
----
include::{sourcetestdir}/eu/europa/esig/dss/cookbook/example/snippets/MSCAPISnippet.java[tags=demo]
----

=== Other Implementations

As you can see, it is easy to add another implementation of the SignatureTokenConnection, thus enabling the framework to use other API than the provided three (PKCS#11, PKCS#12 and MS CAPI). For example, it is likely that in the future PC/SC will be the preferred way of accessing a Smartcard. Although PKCS#11 is currently the most used API, DSS framework is extensible and can use PC/SC. For our design example we propose to use PC/SC to communicate with the Smartcard.

== Management of certificates sources

The validation of a certificate requires the access to some other certificates from multiple sources like trusted lists, trust store, the signature itself: certificates can be contained inside or any other source. 
Within the framework, an X509 certificate is modelled through the class:

 * eu.europa.esig.dss.x509.CertificateToken 
 
This encapsulation helps make certificate handling more suited to the needs of the validation in the context of trust. Each certificate is unambiguously identified by its issuer DN and serial number. The framework associates a unique internal identifier to each certificate but this identifier is not calculated on the data contained in the certificate and therefore varies from one application to another. However, it is independent of its source. It allows to easily comparing certificates issued by different sources.
Certificate tokens are grouped into pools. A certificate token can be declared in several pools. The class that models a pool is called:

 * eu.europa.esig.dss.x509.CertificatePool
 
This class allows keeping only one occurrence of the certificate in the given context (i.e. validation). 
 
The CertificateSource interface provides abstraction for accessing a certificate, regardless of the source. However, each source has its own type:

 * eu.europa.esig.dss.x509.CertificateSourceType
 
This information is used, for example, to distinguish between the certificate from a trusted source and the others. A source has one and only one type, but a certificate token can be found in multiple sources. 
The DSS framework supplies some standard implementations, but also gives the possibility to implement owner solutions. Among the standard solutions you can find:

 * eu.europa.esig.dss.x509.CommonCertificateSource
 
This is the superclass of almost of the certificate sources. 
It implements the common method CommonCertificateSource#get returns the list of CertificateToken(s) corresponding to the given subject distinguished name. Note that the content of the encapsulated certificates pool can be different from the content of the source. Only CertificateToken(s) present in the source are taken into account.
It exposes also the method CommonCertificateSource#addCertificate which gives the possibility to add manually any X509Certificate as a part of this source and as a part of the encapsulated pool. If the certificate is already present in the pool its source type is associated to the token. 

 * eu.europa.esig.dss.x509.SignatureCertificateSource
 
Some certificate sources are based on data encapsulated within the signature. That means that the set of certificates is available and the software only needs to find the certificate using its subject name. This class adds also new methods to obtain specialized  list of certificates contained in the source:.

 ** SignatureCertificateSource#getKeyInfoCertificates
 ** SignatureCertificateSource#getEncapsulatedCertificates

 * eu.europa.esig.dss.tsl.TrustedListsCertificateSource
 
Certificates coming from the list of Trusted Lists. This class gives the mechanism to define the set of trusted certificates (trust anchors). They are used in the validation process to decide if the prospective certificate chain has a trust anchor. See chapter 5.2 to know more about EU Trusted Lists.

== Management of CRL and OCSP sources

A CRL is a time-stamped list identifying revoked certificates. It is signed by a Certificate Authority (CA) and made freely available in a public repository. Each revoked certificate is identified in a CRL by its certificate serial number. 

The Online Certificate Status Protocol (OCSP) is an Internet protocol used for obtaining the revocation status of an unique X.509 digital certificate. 

For every certificate, the validity has to be checked via CRL or OCSP responses. The information may originate from different CRLSources or OCSPSources: 
For easing the usage of such sources, DSS implements a CRLSource and OCSPSource interfaces (which inherit from RevocationSource), which offer a generic, uniform way of accessing CRL and OCSP sources. Furthermore, a caching mechanism can be easily attached to those sources, optimizing the access time to revocation information by reducing network connections to online servers.

The interface CRLSource defines the method which returns CRLToken for the given certificate/issuer certificate couple:

[source,java,indent=0]
.CRLSource usage
----
include::{sourcetestdir}/eu/europa/esig/dss/cookbook/example/snippets/CRLSourceSnippet.java[tags=demo]
----

The interface OCSPSource defines the method which returns OCSPToken for the given certificate/issuer certificate couple:

[source,java,indent=0]
.OCSPSource usage
----
include::{sourcetestdir}/eu/europa/esig/dss/cookbook/example/snippets/OCSPSourceSnippet.java[tags=demo]
----

We use these classes during the certificate validation process through "validationContext" object (based on ValidationContext class) which is a "cache" for one validation request that contains every object retrieved so far. This object in turn instantiates a "verifier" based on CSPAndCRLCertificateVerifier class whose role is to fetch revocation data by querying an OCSP server first and then a CRL server if no OCSP response could be retrieved.
In general we can distinguish three main sources:

 * Offline sources;
 * Online sources;
 * Sources with the cache mechanism.

=== Other implementations of CRL and OCSP Sources

Such sources find the status of a certificate either from a list stored locally or using the information contained in the advanced signature or online way. Here is the list of sources already implemented in the DSS framework:

 * CRL sources
 ** JdbcCacheCRLSource : Retrieves information from a JDBC datasource
 ** OfflineCRLSource : This class that implements in a generic way the findCrl method that operates on the different CRLs implemented in children classes.
 *** ListCRLSource : This source maintains a list of CRLToken. 
 *** SignatureCRLSource : The advanced signature contains a list of CRL that was needed to validate the signature. This class is a basic skeleton that is able to retrieve the needed CRL from a list. The child needs to retrieve the list of wrapped CRLs.
 **** CAdESCRLSource : Retrieves information from a CAdES signature.
 **** PAdESCRLSource : Retrieves information from a PAdES signature.
 **** XAdESCRLSource : Retrieves information from a XAdES signature.
 **** ExternalResourcesCRLSource : A class that can instantiate a list of certificate revocation lists from a directory where should be the individual lists (each individual list file must end with the extension ".crl").
 ** OnlineCRLSource : This is a representation of an Online CRL repository. This implementation will contact using HTTP protocol the CRL Responder to download the CRLs from the given URI. Note that certificate"s Authority Information Access (AIA) extension is used to find issuer's resources location like CRT file and/or Online Certificate Status Protocol (OCSP). The URIs of CRL server will be extracted from this property (OID value: 1.3.6.1.5.5.7.48.1.3).
 * OCSP sources
 ** OfflineOCSPSource : An abstract class that helps to implement OCSPSource with an already loaded list of OCSPToken. It implements in a generic way the getOCSPResponse method that operates on the different OCSP implementations in children classes.
 *** ListOCSPSource : Implements an OCSPSource from a list of OCSPToken.
 *** SignatureOCSPSource : The advanced signature contains a list of OCSPResp that was needed to validate the signature. This class is a basic skeleton that is able to retrieve the needed OCSPResp from a list. The children need to retrieve the list of wrapped OCSPResp.
 **** CAdESOCSPSource : Retrieves information from a CAdES signature.
 **** PAdESOCSPSource : Retrieves information from a PAdES signature.
 **** XAdESOCSPSource : Retrieves information from a XAdES signature.
 **** ExternalResourcesOCSPSource : A class that can instantiate a list of OCSPToken from a directory where should be the individual DER Encoded X509 certificates files (each individual file must end with the extension ".der").
 ** OnlineOCSPSource : This is a representation of an Online OCSP repository. This implementation will contact using HTTP protocol the OCSP Responder to retrieve the OCSP response. Note that certificate's Authority Information Access (AIA) extension is used to find issuer's resources location like CRT file and/or Online Certificate Status Protocol (OCSP). The URIs of OCSP server will be extracted from this property (OID value: 1.3.6.1.5.5.7.48.1). 

== CertificateVerifier configuration

The CertificateVerifier and its implementation CommonCertificateVerifier determine how DSS accesses to external resources and how it should react in some occasions. This configuration is used in both extension and validation mode.

[source,java,indent=0]
.CertificateVerifier usage
----
include::{sourcetestdir}/eu/europa/esig/dss/cookbook/example/snippets/CertificateVerifierSnippet.java[tags=demo]
----

== TSP Sources

The Time Stamp Authority by creating time-stamp tokens provides independent and irrefutable proof of time for business transactions, e-documents and digital signatures. The TSA must comply with the IETF RFC 3161 specifications (cf. <<R07>>). A time-stamp is obtained by sending the digest value of the given data and digest algorithm to the Time Stamp Authority. The returned time-stamp is a signed data that contains the digest value, the identity of the TSA, and the time of stamping. This proves that the given data existed before the time of stamping.
The DSS framework proposes TSPSource interface to implement the communication with TSA. The class OnlineTSPSource is the default implementation of TSP using HTTP(S) communication layer.
The following bit of Java code illustrates how you might use this class:

[source,java,indent=0]
.OnlineTSPSource usage
----
include::{sourcetestdir}/eu/europa/esig/dss/cookbook/example/sources/OnlineTSPSourceTest.java[tags=demo]
----

=== Time-stamp policy

A time-stamp policy is a "named set of rules that indicates the applicability of a time-stamp token to a particular community and/or class of application with common security requirements". A TSA may define its own policy which enhances the policy defined in RFC 3628. Such a policy shall incorporate or further constrain the requirements identified in RFC 3628. A time-stamp policy may be defined by the user of times-stamp services.

=== Composite TSP Source

Sometimes, timestamping servers may encounter interruptions (restart,...). To avoid failing signature extension, DSS allows to configure several TSP Sources. DSS will try source by source until getting an usable timestamp token. 

[source,java,indent=0]
.Configuration of a CompositeTSPSource
----
include::{sourcetestdir}/eu/europa/esig/dss/cookbook/example/sources/CompositeTSPSourceTest.java[tags=demo]
----

== Supported algorithms

DSS supports several signature algorithms (combination of an encryption algorithm and a digest algorithm). Below, you can find the supported combinations. The support of the algorithms depends of the registered OID (ASN1) or URI (XML).

In the next table, XAdES also applies to ASiC with embedded XAdES signatures and CAdES also concerns PAdES and ASiC with embedded CAdES signatures. 

NOTE: SmartCards/HSMs don't allow to sign with all digest algorithms. Please refer to your SmartCard/HSM provider.

[cols="13*^"]
|===
| | SHA-1 | SHA-224 | SHA-256 | SHA-384 | SHA-512 | SHA3-224 | SHA3-256 | SHA3-384 | SHA3-512 | MD2 | MD5 | RIPEMD160

13+|*RSA*

| XAdES | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | | | | | | icon:check-circle[] | icon:check-circle[] 

| CAdES | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] 

13+|*RSA-PSS*

| XAdES | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | | | 

| CAdES | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | | | 

13+|*ECDSA*

| XAdES | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | | | | | | | icon:check-circle[]

| CAdES | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | | | 

13+|*DSA*

| XAdES | icon:check-circle[] | | icon:check-circle[] | | | | | | | | |  

| CAdES | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | | | 

13+|*HMAC*

| XAdES | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | | | | | |  | icon:check-circle[] 

| CAdES | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | icon:check-circle[] | |  |  
|===

== Multi-theading

DSS can be used in multi-threaded environments but some points need to be considered like resources sharing and caching. All operations are stateless and this fact requires to be maintained. Some resources can be shared, others are proper to an operation. 

For each provided operation, DSS requires a CertificateVerifier object. This object is responsible to provide certificates and accesses to external resources (AIA, CRL, OCSP,...). At the beginning of all operation, a new internal CertificatePool is created and all available certificates are copied. Throughout the signature/validation process, the CertificatePool content evolves. Certificates are added/updated from the signature, timestamp(s), revocation data,... Revocation data / issuer certificates are collected and added to the certificate. Certificate status are updated to give as much as possible information. For these reasons, integrators need to be careful about the CertificateVerifier configuration.

=== Resource sharing

The trusted certificates can be shared between multiple threads because these certificates are static. This means they don't require more analysis. Their status won't evolve. For these certificates, DSS doesn't need to collect issuer certificate and/or their revocation data. 

In opposition, the adjunct certificates cannot be shared. These certificates concern a specific signature/validation operation. This parameter is used to provide missing certificate(s). When DSS is unable to build the complete certificate path with the provided certificates (as signature parameters or embedded within a signature), it is possible to inject not present certificates. These certificates are not necessarily trusted and may require future "modifications" like revocation data collection,... 

=== Caching

In case of multi-threading usage, we strongly recommend to cache external resources. All external resources can be cached (AIA, CRL, OCSP) to improve performances and to avoid requesting too much time the same resources. FileCacheDataLoader and JdbcCacheCRLSource can help you in this way. 


== Additional features

=== Certificate validation

DSS offers the possibility to validate a certificate. For a given certificate, the framework builds a certificate path until a known trust anchor (trusted list, keystore,...), validates each found certificate (OCSP / CRL) and determines its European "qualification". 

To determine the certificate qualification, DSS follows the draft standard ETSI TS 119 172-4 (<<R09>>). It analyses the certificate properties (QCStatements, Certificate Policies,...) and applies possible overrules from the related trusted list ("catched" qualifiers from a trust service). More information about qualifiers can be found in the standard ETSI TS 119 612 (<<R10>>).

DSS always computes the status at 2 different times : certificate issuance and signing/validation time. The certificate qualification can evolve in the time, its status is not immutable (eg: a trust service provider lost its granted status). The eIDAS regulation (<<R11>>) clearly defines these different times in the Article 32 and related Annex I. 

[source,java,indent=0]
.Validate a certificate and retrieve its qualification level
----
include::{sourcetestdir}/eu/europa/esig/dss/cookbook/example/validate/CertificateValidationTest.java[tags=demo]
----

=== Extract the signed data from a signature

DSS is able to retrieve the original data from a valid signature. 

[source,java,indent=0]
.Retrieve original data from a signed document
----
include::{sourcetestdir}/eu/europa/esig/dss/cookbook/example/validate/RetrieveOriginalDocumentTest.java[tags=demo]
----

== REST Services

DSS offers some REST and SOAP web services. The documentation will covers the REST calls. Additionally, we also provide a SOAP-UI project and Postman samples in the cookbook module.

The different webservices are : 

 * Signature webservices (dss-soap / dss-rest and their clients) : they expose methods to allow to sign or extend a signature from a client.
 * Server-signing webservice (dss-server-signing-soap / dss-server-signing-rest and their clients) : they expose method to retrieve keys from a server (PKCS#11, PKCS#12, HSM,...) and to sign the digest on the server side.
 * Validation webservices (dss-validation-soap / dss-validation-rest and their client) : they expose methods to allow validate a signature, with an optional detached file and an optional validation policy.
 
The data structure in webservices is similar in REST and SOAP.

=== REST signature service

This service exposes 3 methods for one or more document(s) : 

 * getDataToSign : computes the digest to be signed
 * signDocument : adds the signature value in the document
 * extendDocument : extends an existing signature
 
==== Get data to sign

The method allows to retrieve the data to be signed. The user sends the document to be signed, the parameters (signature level,...) and the certificate chain. 

WARNING: The parameters in getDataToSign and signDocument MUST be the same (especially the signing date).

.Request
include::restdocs/get-data-to-sign-one-document/http-request.adoc[]

.Response
include::restdocs/get-data-to-sign-one-document/http-response.adoc[]

==== Sign document

The method allows to generate the signed document with the received signature value.

WARNING: The parameters in getDataToSign and signDocument MUST be the same (especially the signing date).

.Request
include::restdocs/sign-document-one-document/http-request.adoc[]

.Response
include::restdocs/sign-document-one-document/http-response.adoc[]

==== Extend document

The method allows to extend an existing signature to a stronger level.

.Request
include::restdocs/extend-one-document/http-request.adoc[]

.Response
include::restdocs/extend-one-document/http-response.adoc[]

=== REST server signature service

This service also exposed 3 methods : 

 * getKeys : retrieves available keys on server side
 * getKey : retrieves a key on the server side by its alias
 * sign : signs the digest value with the given key

==== Get keys

This method allows to retrieve all available keys on the server side (PKCS#11, PKCS#12, HSM,...). All keys will have an alias, a signing certificate and its chain. The alias will be used in following steps.

.Request
include::restdocs/get-keys/http-request.adoc[]

.Response
include::restdocs/get-keys/http-response.adoc[]

==== Get key

This method allows to retrieve key informations for a given alias.

.Request
include::restdocs/get-key/http-request.adoc[]

.Response
include::restdocs/get-key/http-response.adoc[]

==== Sign

This method allows to sign the given digest with a server side certificate.

.Request
include::restdocs/sign/http-request.adoc[]

.Response
include::restdocs/sign/http-response.adoc[]

=== REST validation service

==== Validate a document

This service allows to validate signature (all formats/types) against a validation policy.

.Request
include::restdocs/validate-doc/http-request.adoc[]

.Response
include::restdocs/validate-doc/http-response.adoc[]

==== Retrieve original document(s)

This service returns the signed data for a given signature.

.Request
include::restdocs/get-original-documents/http-request.adoc[]

.Response
include::restdocs/get-original-documents/http-response.adoc[]
